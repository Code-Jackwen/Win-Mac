package com.nyist.xu.sort;

import java.util.Arrays;

/**
 * @program: nyisttest
 * @description
 * @author: xu1
 * @create: 2020-04-21 20:50
 **/
public class InsertionSort {

    //1、算法思路：每趟将一个待排序的元素作为关键字，按照其关键字值得大小插入到已经排好的部分的适当位置上，知道插入完成。
    //
    //2、算法过程
    //
    //举个栗子（第一趟的排序过程）
    //
    //原始序列：49、38、65、97、76、13、27、49
    //
    //1)开始以第一个元素49为关键字，看成一个序列，其余数看成另一个序列，此时一个关键字数49序列是有序的。
    //
    //结果：{49}   {38、65、97、76、13、27、49}
    //
    //2）插入38。38<49，所以49向后移动一个位置，38插入到原49位置
    //
    //结果：{38、49}   {65、97、76、13、27、49}
    //
    //3）插入65。65>49，所以不需要移动，65插入49之后
    //
    //结果：{38、49、65}   {97、76、13、27、49}
    //
    //4）插入97。97>65，所以不需要移动，97插入65之后
    //
    //结果：{38、49、65、97}   {、13、27、49}
    //
    //5）插入76。76<97，所以97向后移动一个位置，继续比较，76>65,65不需要移动，76插入到65之后，97之前的位置
    //
    //结果：{38、49、65、76、97}   {、13、27、49}
    //
    //6）插入13。13<97，所以97向后移动一个位置，继续比较，13>76，所以76向后移动一个位置不需要移动，继续比较，13>65，逐次比较，发现13应插入最前位置
    //
    //结果：{13、38、49、65、76、97}   {、27、49}
    //
    //7）插入27。27<97，所以97向后移动一个位置，继续比较，27>76，所以76向后移动一个位置不需要移动，继续比较，27>65，逐次比较，发现27应插入13之后，38之前
    //
    //结果：{13、27、38、49、65、76、97}   {、49}
    //
    //8）最后插入剩余元素49。同理逐次比较，发现49=49<65，应插入49之后，65之前位置
    //
    //结果：{13、27、38、49、49、65、76、97}  
    //
    //排序结束，得到一个有效序列
    //————————————————
    //版权声明：本文为CSDN博主「那人好像一条猿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    //原文链接：https://blog.csdn.net/changhangshi/article/details/82737294


    public static void main(String[] args) {
        int[] arr = {49,38,65,97,76,13,27,49};
        System.out.println(Arrays.toString(insertionSort(arr, arr.length)));
    }

    public static int[] insertionSort(int[] arr, int n) {
        int i, j, temp;
        for (i = 1; i < n; i++) {
            temp = arr[i];
            for (j = i; j > 0 && arr[j - 1] > temp; j--) {
                arr[j] = arr[j - 1];
            }
            arr[j] = temp;
            System.out.println(Arrays.toString(arr));
        }
        return arr;
    }
}
